/**
 * \file
 *
 * \brief Empty user application template
 *
 */

/**
 * \mainpage User Application template doxygen documentation
 *
 * \par Empty user application template
 *
 * Bare minimum empty user application template
 *
 * \par Content
 *
 * -# Include the ASF header files (through asf.h)
 * -# "Insert system clock initialization code here" comment
 * -# Minimal main function that starts with a call to board_init()
 * -# "Insert application code here" comment
 *
 */

/*
 * Include header files for all drivers that have been imported from
 * Atmel Software Framework (ASF).
 */
/*
 * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
 */
#include <asf.h>
#include <stdio.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "uart.h"
#include "util/delay.h"

/*volatile int timer = 0; // timer in ms */

volatile unsigned int edge1, edge2, diff, space_counter;
volatile char buffer[5];
volatile unsigned int b_index = 0;
/*
ISR(TIMER1_CAPT_vect) {
	TCCR1B ^= 0x40;
	PORTB ^= 0x20;
	putchar('s');
}


int main (void)
{
	uart_init();
	DDRB = 0x20;	//enable pin 13 write
	TCCR1B = 0x01;	//setting the clock on
	TIMSK1 = 0x20;	//allow interrupts
	sei();
	while(1);
}*/


ISR(TIMER1_CAPT_vect) {
	//count time, store in variable
	//casework on time
	if (!(PINB & 0x01)) {
		//putchar('f');		//for debugging
		edge1 = ICR1;		//store time of first (falling) edge
		TCCR1B |= 0x40;		//flips ICES1 bit, next capture on rising bit
		space_counter = ICR1 - space_counter;
		if (space_counter > 25000) {
			//space
			putchar(' ');
		}
	} 
	if (PINB & 0x01) {
		//putchar('r');		//for debugging
		edge2 = ICR1;		//store time of second (rising) edge
		diff = edge2-edge1;	//for morse logic
		if (diff < 1875) {
		} else if (diff < 12500) {
			//dot
			putchar('.');
			buffer[b_index] = '.';
			b_index++;
			PORTB = 0x10;
			_delay_ms(50);
			PORTB &= ~(0x10);
		} else {
			//dash
			putchar('-');
			buffer[b_index] = '-';
			b_index++;
			PORTB = 0x08;
			_delay_ms(50);
			PORTB &= ~(0x08);
		}
		space_counter = ICR1;
		TCCR1B &= ~(0x40);		//flips ICES1 bit, next capture on falling bit
	}
}

char decode() {
	if (buffer[0] == '.') {
		//e tree
		if (buffer[1] == '.') {
			//i tree
			if (buffer[2] == '.') {
				//s tree
				if (buffer[3] == '.') {
					//h tree
					if (buffer[4] == '.') {
						return ('5');
					} else if (buffer[4] == '-') {
						return ('4');
					} else {
						return('H');
					}
				} else if (buffer[3] == '-') {
					if (buffer[4] == '.') {
						//do nothing
					} else if (buffer[4] == '-') {
						return('3');
					} else {
						return('V');
					}
				} else {
					return('S');
				}
			} else if (buffer[2] == '-') {
				//u tree
				if (buffer[3] == '.') {
					//f tree
					if ((buffer[4] == '.') || (buffer[4] == '-')) {
						//do nothing
					} else {
						return('F');
					}
				} else if (buffer[3] == '-') {
					if (buffer[4] == '.') {
						//do nothing
					}
					else if (buffer[4] == '-') {
						return('2');
					}
					else {
						//do nothing b/c (..--) is not a valid char sequence
					}
				} else {
					return('U');
				}
			} else {
				return('I');
			}
		} else if (buffer[1] == '-') {
			//a tree
			if (buffer[2] == '.') {
				//r tree
				if (buffer[3] == '.') {
					//l tree
					if ((buffer[4] == '.') || (buffer[4] == '-')) {
						//do nothing
					} else {
						return('L');
					}
				} else if (buffer[3] == '-') {
					//do nothing b/c (.-.-) is not a valid char sequence
				} else {
					return('R');
				}
			} else if (buffer[2] == '-') {
				//w tree
				if (buffer[3] == '.') {
					//p tree
					if ((buffer[4] == '.') || (buffer[4] == '-')) {
						//do nothing
					} else {
						return('P');
					}
				} else if (buffer[3] == '-') {
					//j tree
					if (buffer[4] == '.') {
						//do nothing b/c (.---.) is not a valid char sequence
					} else if (buffer[4] == '-') {
						return('1');
					} else {
						return('J');
					}
				} else {
					return('W');
				}
			} else {
				return('A');
			}
		} else {
			return('E');
		}
	else if (buffer[0] == '-') {
		//t tree
		if (buffer[1] == '.') {
			//n tree
			if (buffer[2] == '.') {
				//d tree
				if (buffer[3] == '.') {
					//b tree
					if (buffer[4] == '.') {
						return('6');
					} else if (buffer[4] == '-') {
						//do nothing b/c (-...-) is not a valid char sequence
					} else {
						return('B');
					}
				} else if (buffer[3] == '-') {
					//x tree
					if ((buffer[4] == '.') || (buffer[4] == '-')) {
						//do nothing
					} else {
						return('X');
					}
				} else {
					return('D');
				}
			} else if (buffer[2] == '-') {
				//k tree
				if (buffer[3] == '.') {
					//c tree
					if ((buffer[4] == '.') || (buffer[4] == '-')) {
						//do nothing
					} else {
						return('C');
					}
				} else if (buffer[3] == '-') {
					//y tree
					if ((buffer[4] == '.') || (buffer[4] == '-')) {
						//do nothing
					} else {
						return('Y');
					}
				} else {
					return('K');
				}
			} else {
				return('N');
			}
		} else if (buffer[1] == '-') {
			//m tree
			if (buffer[2] == '.') {
				//g tree
				if (buffer[3] == '.') {
					//z tree
					if (buffer[4] == '.') {
						return('7');
					} else if (buffer[4] == '-') {
						//do nothing b/c (--..-) is not a valid char sequence
					} else {
						return('Z');
					}
				} else if (buffer[3] == '-') {
					//q tree 
					if ((buffer[4] == '.') || (buffer[4] == '-')) {
						//do nothing
					} else {
						return('Q');
					}
				} else {
					return('G');
				}
			} else if (buffer[2] == '-') {
				//o tree
				if (buffer[3] == '.') {
					//8 tree
					if (buffer[4] == '.') {
						return('8');
					} else if (buffer[4] == '-') {
						//do nothing b/c (---.-) is not a valid char sequence
					} else {
						//do nothing b/c (---.) is not a valid char sequence
					}
				}
				else if (buffer[3] == '-') {
					//9,0 tree
					if (buffer[4] == '.') {
						return('9');
					} else if (buffer[4] == '-') {
						return('0');
					} else {
						//do nothing b/c (----) is not a valid char sequence
					}
				} else {
					return('O');
				}
			} else {
				return('M');
			}
		} else {
			return('T');
		}
}


int main (void)
{
	TIMSK1 = 0x20;		//enable interrupt on input capture
	DDRB = 0x18;		//write enable pin 13
	uart_init();
	TCCR1B = 0x04;		//timer 1, prescaler of 256
						//input capture on falling edge
	TIFR1 |= 0x20;		//clear input capture flag
	sei();				//enable interrupts
	while(1);
}










